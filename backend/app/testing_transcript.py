# backend/app/seed_lecture.py
import os
import sys
from uuid import uuid4 # To generate a new UUID for the lecture if needed by your schema
import asyncio
import json
import websockets
from pathlib import Path
import wave
import time

# Add the parent directory to Python path to allow imports
sys.path.append(str(Path(__file__).parent.parent))

from app.config import settings
from app.summarizer import Summarizer as SummarizerService # Use the actual class name
from app.db import supabase # Your initialized Supabase client

# --- Configuration ---
# !!! REPLACE WITH YOUR ACTUAL TEST USER ID FROM SUPABASE AUTH !!!
TEST_USER_ID = "ff2e01ca-fca8-4f73-a288-405aa4879d42" 
TRANSCRIPT_FILE_PATH = "/Users/kevinton/Desktop/Projects/ai-notes/backend/app/transcript.txt" # In the same backend/app/ directory

def create_mock_lecture(user_id: str, transcript_content: str):
    if user_id == "YOUR_SUPABASE_USER_ID_HERE":
        print("ERROR: Please update TEST_USER_ID in the script with a valid Supabase User ID.")
        return

    print(f"Processing transcript for user: {user_id}")

    summarizer = SummarizerService(api_key=settings.OPENAI_API_KEY)

    # 1. Summarize the transcript
    print("Summarizing transcript with OpenAI...")
    full_summary_text = summarizer.summarize(transcript_content)
    if "Error generating summary" in full_summary_text or \
       "No transcript provided to summarize" in full_summary_text:
        print(f"Failed to generate summary: {full_summary_text}")
        return
    print("Summary generated.")
    # print("\n--- Full Summary Text ---\n", full_summary_text) # Optional: print full summary

    # 2. Parse the summary into structured data
    print("Parsing structured summary...")
    structured_summary_data = summarizer.parse_structured_summary(full_summary_text)
    print("Summary parsed.")
    # print("\n--- Structured Summary ---\n", structured_summary_data) # Optional: print structured data

    # 3. Prepare data for insertion
    # Use lecture_title from AI if available, otherwise generate a fallback
    lecture_title_from_ai = structured_summary_data.get("lecture_title")
    final_title = "Seeded Lecture" # Default fallback
    if lecture_title_from_ai and lecture_title_from_ai.lower() not in ["none", "not available", ""]:
        final_title = lecture_title_from_ai
    elif transcript_content: # Fallback to transcript start if AI title is bad
        final_title = transcript_content.split('.')[0].strip()
        if len(final_title) > 150:
            final_title = ' '.join(final_title.split()[:15]) + '...'
        if not final_title: # If transcript is very short or starts weirdly
             final_title = f"Lecture seeded on {datetime.now().strftime('%Y-%m-%d')}"


    lecture_data_to_insert = {
        "user_id": user_id,
        "transcript": transcript_content,
        "summary": full_summary_text, 
        "lecture_title": final_title, # Using your DB column name
        "topic_summary_sentence": structured_summary_data.get("topic_summary_sentence"),
        "key_concepts": structured_summary_data.get("key_concepts"),
        "main_points_covered": structured_summary_data.get("main_points_covered"),
        "examples_mentioned": structured_summary_data.get("examples_mentioned"),
        "important_quotes": structured_summary_data.get("important_quotes"),
        "conclusion_takeaways": structured_summary_data.get("conclusion_takeaways"),
        "references": structured_summary_data.get("references"), # Make sure this matches your DB column name
        # 'id' and 'created_at', 'updated_at' are usually auto-generated by Supabase
    }
    # Remove None values if your DB has constraints or if you prefer cleaner inserts
    # lecture_data_to_insert = {k: v for k, v in lecture_data_to_insert.items() if v is not None}


    # 4. Insert into Supabase
    print(f"Inserting lecture titled '{final_title}' into Supabase...")
    try:
        response = supabase.table("lectures").insert(lecture_data_to_insert).execute()
        if response.data and len(response.data) > 0:
            inserted_lecture_id = response.data[0].get('id')
            print(f"Successfully inserted lecture! ID: {inserted_lecture_id}")
            print(f"You should now be able to see this lecture in the frontend for user {user_id}.")
        else:
            print("Failed to insert lecture. No data returned from Supabase.")
            if hasattr(response, 'error') and response.error:
                print(f"Supabase error: {response.error}")

    except Exception as e:
        print(f"Error inserting lecture into Supabase: {e}")
        import traceback
        traceback.print_exc()

def main():
    if not settings.OPENAI_API_KEY or not settings.SUPABASE_URL or not settings.SUPABASE_KEY:
        print("Error: Missing one or more required environment variables (OPENAI_API_KEY, SUPABASE_URL, SUPABASE_KEY).")
        return

    try:
        with open(TRANSCRIPT_FILE_PATH, 'r', encoding='utf-8') as f:
            sample_transcript = f.read()
    except FileNotFoundError:
        print(f"Error: Transcript file not found at '{TRANSCRIPT_FILE_PATH}'.")
        print("Place your sample_lecture_transcript.txt in the backend/app/ directory.")
        return
    
    if not sample_transcript.strip():
        print(f"Error: The transcript file '{TRANSCRIPT_FILE_PATH}' is empty.")
        return

    create_mock_lecture(TEST_USER_ID, sample_transcript)

if __name__ == "__main__":
    from datetime import datetime # For fallback title
    main()